#pragma config(Sensor, S1,     colorS,         sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S2,     leftS,          sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S3,     rightS,         sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S4,     ,               sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Motor,  motorA,          manipMotor,    tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorD,          liftMotor,     tmotorEV3_Medium, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int firstScan = 0, secondScan = 0;
int colors[4];
bool busy1 = false, busy2 = false, busy3 = false, busy4 = false;

long r1Min = 0;
long g1Min = 38;
long b1Min = 39;
long r1Max = 263;
long g1Max = 278;
long b1Max = 336;

long r2Min = 22;
long g2Min = 47;
long b2Min = 42;
long r2Max = 151;
long g2Max = 276;
long b2Max = 356;

long r1MinBlueGray = 0;
long g1MinBlueGray = 38;
long b1MinBlueGray = 39;
long r1MaxBlueGray = 263;
long g1MaxBlueGray = 278;
long b1MaxBlueGray = 336;

long r2MinBlueGray = 22;
long g2MinBlueGray = 47;
long b2MinBlueGray = 42;
long r2MaxBlueGray = 151;
long g2MaxBlueGray = 276;
long b2MaxBlueGray = 356;

int startDefault = 20;
int stopDefault = 20;

#include "includes/hitechnic-colour-v2.h"
tHTCS2 s;

#include "includes/math.h"
#include "includes/structures.h"
#include "includes/sensors.h"
#include "includes/stop.h"
#include "includes/acceleration.h"
#include "includes/colorsCheckers.h"
#include "includes/debugger.h"
#include "includes/line.h"
#include "includes/motorSync.h"
#include "includes/manipulator.h"
#include "includes/lift.h"
#include "includes/drive.h"
#include "includes/cubes.h"

task main() {
	initColors();
	startTask(initLift);
	startTask(PIDLift);
	startTask(initManip);
	startTask(PIDManip);
	initSensor(&s, S1);
	registerMapping();
	registerLine(grayLineLeft, grayLineRight, "valsGray.txt");
	registerLine(whiteLineLeft, whiteLineRight, "valsWhite.txt");

	clearTimer(T4);

	//showRGB(leftS);

	delay(600);
	medium();
	open();

	driveCM(50, 6, 20, 0);
	lineS2InnerCM(50, 18, 0, 0);
	driveCM(50, 12.5, 0, 0);
	firstScan = getColor(s);
	driveCM(50, 5, 0, 20);
	stopBC();
	secondScan = getColor(s);
	driveCM(100, -7);
	stopBC();
	turn(100, 90);
	stopBC();
	lineCM(100, 14, 40, 40);
	arc(100, -16, 90, 40, 40);
	arc(100, 16, 90, 40, 40);

	colors[0] = getColor(s);
	driveCM(60, 2, 40, 0);
	lineBlueGrayCM(60, 5.5, 0, 0);
	colors[1] = getColor(s);
	lineBlueGrayCM(60, 7, 0, 0);
	colors[2] = getColor(s);
	driveCM(60, 7, 0, 40);
	colors[3] = getColor(s);
	liftDown();
	openFULL();
	arc(60, -25, 35, 40, 40);
	driveCM(60, 3, 40, 40);
	stopBC();
	close();
	delay(250);
	liftUp();
	delay(300);
	arc(60, 35, 35, 40, 40);
	stopBC();
	medium();
	arc(100, 30, -35, 40, 40);
	driveCM(100, -43, 40, 20);
	turnLineLeft(100, 40);

	lineCM(100, 12, 100, 20);
	XCross(20, 1, 20, grayLineLeft, grayLineRight);
	stopBC();

	driveCM(100, -12);
	stopBC();
	liftDown();
	delay(200);

	int toSmall = 0;
	if(firstScan == 0 && secondScan == 0) {
		toSmall = 1;
	} else if(firstScan == 1 && secondScan == 1) {
		toSmall = 0;
	} else {
		toSmall = 1;
	}

	if(colors[0] == toSmall) {
		cube1(-24, 0);
		busy1 = true;
		medium();
		turnLine180(100, -145);
	} else if(colors[1] == toSmall) {
		cube2(-7, 0);
		busy2 = true;
		medium();
		turnLine180(100, -165);
	} else if(colors[2] == toSmall) {
		cube3(9, 0);
		busy3 = true;
		medium();
		turnLine180(100, 165);
	} else {
		cube4(23, 0);
		busy4 = true;
			medium();
		turnLine180(100, 145);
	}

	XCross(100, 1, 100);
	lineCM(100, 28, 0, 20);
	XCross(40, 1);
	stopBC();
	liftUp();
	delay(400);
	driveCM(100, -23, 40, 40);
	stopBC();
	turnLineLeft(100, 70, 40);
	XCross(100, 1, 80);
	lineCM(100, 42, 0, 40);
	arc(100, 15, 90, 40);
	stopBC();
	liftToShip();
	delay(400);
	open();
	delay(100);
	driveCM(100, -15);
	stopBC();
		medium();
	turnLineRight(100);

	XCross(100, 2, 100);
	lineCM(100, 7, 0, 20);
	stopBC();
	turnLineRight(100);

	lineCM(100, 30, 100, 20);
	XCross(20, 1, 20, grayLineLeft, grayLineRight);
	stopBC();
	driveCM(80, -12);
	stopBC();

	liftDown();

	if(!busy1 && !busy2 && ((colors[0] == firstScan && colors[1] == secondScan) || (colors[1] == firstScan && colors[0] == secondScan))) {
		cube1(-24, 17);
		cube2(0, 7);
	} else if(!busy2 && !busy3 && ((colors[1] == firstScan && colors[2] == secondScan) || (colors[2] == firstScan && colors[1] == secondScan))) {
		cube2(-7, 16);
		cube3(0, -9);
	} else if(!busy3 && !busy4 && ((colors[2] == firstScan && colors[3] == secondScan) || (colors[3] == firstScan && colors[2] == secondScan))) {
		cube3(9, 14);
		cube4(0, -23);
	} else if(!busy1 && !busy3 && ((colors[0] == firstScan && colors[2] == secondScan) || (colors[2] == firstScan && colors[0] == secondScan))) {
		cube1(-24, 33);
		cube3(0, -9);
	} else if(!busy2 && !busy4 && ((colors[1] == firstScan && colors[3] == secondScan) || (colors[3] == firstScan && colors[1] == secondScan))) {
		cube2(-7, 30);
		cube4(0, -23);
	} else {
		cube1(-24, 47);
		cube4(0, -23);
	}

	liftToShip();
	driveCM(50, 6, 20, 20);
	stopBC();
	turn(100, -90);
	stopBC();
	liftDown();
	driveCM(100, 5, 20, 0);
	open();
	driveCM(100, 3, 0, 0);
	close();
	driveCM(100, 3, 0, 0);
	medium();
	driveCM(100, 28, 0, 20);
	liftUp();
	driveCM(20, 4, 20, 20);
	stopBC();
	delay(150);
	turn(100, -120, 40, 45);
	stopBC();
	driveCM(100, 33, 40, 40);
	stopBC();
	turnLineLeft(60, 45, 55);
	liftUp();
	XCross(100, 3, 55);
	driveCM(100, 7, 0, 40);
	stopBC();
	turnLineRight(60, 77, 50);
	lineCM(100, 23.5, 55, 40);
	stopBC();
	driveCM(100, -18, 40, 40);
	stopBC();
	liftToShip();
	driveCM(100, 3, 40, 40);
	stopBC();
	driveCM(80, -1.25);
	stopBC();
	wideOpen();
	delay(300);
	liftUp();

	driveCM(100, -14, 0, 20);
	stopBC();

	turn(100, -15);
	stopBC();
	liftDown();
	delay(500);
	close();
	delay(200);
	medium();
	driveCM(100, 14);
	stopBC();
	liftToShip();
	delay(500);
	open();
	delay(200);
	medium();
	driveCM(100, -12);
	stopBC();
	turnLine180(50, -140);
	lineCM(50, 19, 50, 0);
	liftUp();
	openFULL();
	driveCM(50, 16, 0, 16);
	stopBC();

	eraseDisplay();
	displayBigTextLine(0, "%d", time1[T4]);
	delay(100000);
}
